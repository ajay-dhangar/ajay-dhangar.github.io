"use strict";(self.webpackChunkcode_harbor_hub=self.webpackChunkcode_harbor_hub||[]).push([[37204],{59644:(e,a,o)=>{o.r(a),o.d(a,{assets:()=>t,contentTitle:()=>n,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>r});var c=o(17624),s=o(4552);const i={id:"scopes-in-javascript",title:"Scopes in JavaScript",sidebar_label:"Scopes",sidebar_position:32,tags:["JavaScript","Scopes","Global Scope","Local Scope","Function Scope","Block Scope","Lexical Scope","Closures","Hoisting","Temporal Dead Zone","Global Object","Strict Mode","Module Scope"],description:"In this tutorial, we will learn about scopes in JavaScript. A scope is a region of a program where a variable is defined and can be accessed. We will see the different types of scopes in JavaScript and how they work."},n=void 0,l={id:"javascript/scopes-in-javascript",title:"Scopes in JavaScript",description:"In this tutorial, we will learn about scopes in JavaScript. A scope is a region of a program where a variable is defined and can be accessed. We will see the different types of scopes in JavaScript and how they work.",source:"@site/docs/javascript/scope.md",sourceDirName:"javascript",slug:"/javascript/scopes-in-javascript",permalink:"/docs/javascript/scopes-in-javascript",draft:!1,unlisted:!1,editUrl:"https://github.com/Ajay-Dhangar/code-harbor-hub/edit/main/docs/javascript/scope.md",tags:[{label:"JavaScript",permalink:"/docs/tags/java-script"},{label:"Scopes",permalink:"/docs/tags/scopes"},{label:"Global Scope",permalink:"/docs/tags/global-scope"},{label:"Local Scope",permalink:"/docs/tags/local-scope"},{label:"Function Scope",permalink:"/docs/tags/function-scope"},{label:"Block Scope",permalink:"/docs/tags/block-scope"},{label:"Lexical Scope",permalink:"/docs/tags/lexical-scope"},{label:"Closures",permalink:"/docs/tags/closures"},{label:"Hoisting",permalink:"/docs/tags/hoisting"},{label:"Temporal Dead Zone",permalink:"/docs/tags/temporal-dead-zone"},{label:"Global Object",permalink:"/docs/tags/global-object"},{label:"Strict Mode",permalink:"/docs/tags/strict-mode"},{label:"Module Scope",permalink:"/docs/tags/module-scope"}],version:"current",lastUpdatedBy:"ajay-dhangar",lastUpdatedAt:1710954353e3,sidebarPosition:32,frontMatter:{id:"scopes-in-javascript",title:"Scopes in JavaScript",sidebar_label:"Scopes",sidebar_position:32,tags:["JavaScript","Scopes","Global Scope","Local Scope","Function Scope","Block Scope","Lexical Scope","Closures","Hoisting","Temporal Dead Zone","Global Object","Strict Mode","Module Scope"],description:"In this tutorial, we will learn about scopes in JavaScript. A scope is a region of a program where a variable is defined and can be accessed. We will see the different types of scopes in JavaScript and how they work."},sidebar:"javascript",previous:{title:"Errors",permalink:"/docs/javascript/errors-in-javascript"},next:{title:"Strict Mode",permalink:"/docs/javascript/strict-mode-in-javascript"}},t={},r=[{value:"Global Scope",id:"global-scope",level:2},{value:"Local Scope (Function Scope)",id:"local-scope-function-scope",level:2},{value:"Block Scope",id:"block-scope",level:2},{value:"Lexical Scope",id:"lexical-scope",level:2},{value:"Scope Chain",id:"scope-chain",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const a={admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.M)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(a.p,{children:"In JavaScript, a scope is a region of a program where a variable is defined and can be accessed. JavaScript has three types of scopes:"}),"\n",(0,c.jsxs)(a.ol,{children:["\n",(0,c.jsxs)(a.li,{children:[(0,c.jsx)(a.strong,{children:"Global Scope"}),": The global scope is the outermost scope in JavaScript. Variables declared outside of any function or block have global scope. Global variables can be accessed from any part of the program."]}),"\n",(0,c.jsxs)(a.li,{children:[(0,c.jsx)(a.strong,{children:"Local Scope (Function Scope)"}),": The local scope is the innermost scope in JavaScript. Variables declared inside a function have local scope. Local variables can only be accessed from within the function in which they are declared. Each function has its own local scope. When a function is called, a new local scope is created. When the function returns, the local scope is destroyed. Local Scope is also known as Function Scope."]}),"\n",(0,c.jsxs)(a.li,{children:[(0,c.jsx)(a.strong,{children:"Block Scope"}),": The block scope is the scope of a block of code enclosed in curly braces ",(0,c.jsx)(a.code,{children:"{}"}),". Variables declared inside a block have block scope. Block scope is introduced in ECMAScript 6 (ES6) using the ",(0,c.jsx)(a.code,{children:"let"})," and ",(0,c.jsx)(a.code,{children:"const"})," keywords. Block scope is not available in ECMAScript 5 (ES5) and earlier versions."]}),"\n"]}),"\n",(0,c.jsx)(a.h2,{id:"global-scope",children:"Global Scope"}),"\n",(0,c.jsx)(a.p,{children:"The global scope is the outermost scope in JavaScript. Variables declared outside of any function or block have global scope. Global variables can be accessed from any part of the program. For example:"}),"\n",(0,c.jsx)(a.pre,{children:(0,c.jsx)(a.code,{className:"language-javascript",metastring:'title="app.js"',children:'let name = "Ajay Dhangar"; // Global variable\n\nfunction greet() {\n    console.log("Hello, " + name); // Accessing global variable\n}\n\ngreet(); // Output: Hello, Ajay Dhangar\n'})}),"\n",(0,c.jsxs)(a.p,{children:["In the above example, the variable ",(0,c.jsx)(a.code,{children:"name"})," is declared outside of any function, so it has global scope. The ",(0,c.jsx)(a.code,{children:"greet"})," function can access the ",(0,c.jsx)(a.code,{children:"name"})," variable."]}),"\n",(0,c.jsx)(a.h2,{id:"local-scope-function-scope",children:"Local Scope (Function Scope)"}),"\n",(0,c.jsx)(a.p,{children:"The local scope is the innermost scope in JavaScript. Variables declared inside a function have local scope. Local variables can only be accessed from within the function in which they are declared. Each function has its own local scope. When a function is called, a new local scope is created. When the function returns, the local scope is destroyed. Local Scope is also known as Function Scope. For example:"}),"\n",(0,c.jsx)(a.pre,{children:(0,c.jsx)(a.code,{className:"language-javascript",metastring:'title="app.js"',children:'function greet() {\n    let message = "Hello, World!"; // Local variable\n    console.log(message); // Accessing local variable\n}\n\ngreet(); // Output: Hello, World!\nconsole.log(message); // ReferenceError: message is not defined\n'})}),"\n",(0,c.jsxs)(a.p,{children:["In the above example, the variable ",(0,c.jsx)(a.code,{children:"message"})," is declared inside the ",(0,c.jsx)(a.code,{children:"greet"})," function, so it has local scope. The ",(0,c.jsx)(a.code,{children:"greet"})," function can access the ",(0,c.jsx)(a.code,{children:"message"})," variable, but it cannot be accessed outside of the function."]}),"\n",(0,c.jsx)(a.h2,{id:"block-scope",children:"Block Scope"}),"\n",(0,c.jsxs)(a.p,{children:["The block scope is the scope of a block of code enclosed in curly braces ",(0,c.jsx)(a.code,{children:"{}"}),". Variables declared inside a block have block scope. Block scope is introduced in ECMAScript 6 (ES6) using the ",(0,c.jsx)(a.code,{children:"let"})," and ",(0,c.jsx)(a.code,{children:"const"})," keywords. Block scope is not available in ECMAScript 5 (ES5) and earlier versions. For example:"]}),"\n",(0,c.jsx)(a.pre,{children:(0,c.jsx)(a.code,{className:"language-javascript",metastring:'title="app.js"',children:"if (true) {\n    let x = 10; // Block-scoped variable\n    console.log(x); // Accessing block-scoped variable\n}\n\nconsole.log(x); // ReferenceError: x is not defined\n"})}),"\n",(0,c.jsxs)(a.p,{children:["In the above example, the variable ",(0,c.jsx)(a.code,{children:"x"})," is declared inside the block of code, so it has block scope. The ",(0,c.jsx)(a.code,{children:"x"})," variable can only be accessed within the block in which it is declared. It cannot be accessed outside of the block."]}),"\n",(0,c.jsx)(a.h2,{id:"lexical-scope",children:"Lexical Scope"}),"\n",(0,c.jsx)(a.p,{children:"Lexical scope is a scope in which a variable is defined at the time of writing the code. JavaScript uses lexical scope to resolve variable names. When a variable is referenced, JavaScript looks up the variable in the scope in which it was defined. If the variable is not found in the current scope, JavaScript looks up the variable in the outer scope. This process continues until the variable is found or the global scope is reached."}),"\n",(0,c.jsx)(a.p,{children:"Here is an example of lexical scope:"}),"\n",(0,c.jsx)(a.pre,{children:(0,c.jsx)(a.code,{className:"language-javascript",metastring:'title="app.js"',children:'let name = "Ajay Dhangar"; // Global variable\n\nfunction greet() {\n    let message = "Hello, " + name; // Accessing global variable\n    console.log(message);\n}\n\ngreet(); // Output: Hello, Ajay Dhangar\n'})}),"\n",(0,c.jsxs)(a.p,{children:["In the above example, the ",(0,c.jsx)(a.code,{children:"greet"})," function can access the ",(0,c.jsx)(a.code,{children:"name"})," variable, which is defined in the global scope. This is an example of lexical scope."]}),"\n",(0,c.jsxs)(a.admonition,{title:"\ud83d\udcda Learn More:",type:"info",children:[(0,c.jsxs)(a.p,{children:[(0,c.jsx)(a.strong,{children:"Closures:"}),"  In JavaScript, a closure is a function that has access to its own scope, the outer function's scope, and the global scope. Closures are used to create private variables and to encapsulate functionality. Lexical scope is an important concept in understanding closures."]}),(0,c.jsx)(a.p,{children:"Example of a closure with lexical scope for better understanding:"}),(0,c.jsx)(a.pre,{children:(0,c.jsx)(a.code,{className:"language-javascript",metastring:'title="app.js"',children:"function outer() {\n    let x = 10; // Outer function variable\n    function inner() {\n        console.log(x); // Accessing outer function variable\n    }\n    return inner;\n}\n\nlet innerFunction = outer();\ninnerFunction(); // Output: 10\n"})}),(0,c.jsxs)(a.p,{children:["In this example, the ",(0,c.jsx)(a.code,{children:"inner"})," function has access to the ",(0,c.jsx)(a.code,{children:"x"})," variable, which is defined in the ",(0,c.jsx)(a.code,{children:"outer"})," function. This is an example of a closure with lexical scope. The ",(0,c.jsx)(a.code,{children:"inner"})," function has access to the ",(0,c.jsx)(a.code,{children:"x"})," variable even after the ",(0,c.jsx)(a.code,{children:"outer"})," function has returned."]}),(0,c.jsxs)(a.p,{children:["In the above example, the lexical scope of the ",(0,c.jsx)(a.code,{children:"inner"})," function includes the scope of the ",(0,c.jsx)(a.code,{children:"outer"})," function, which is why the ",(0,c.jsx)(a.code,{children:"inner"})," function can access the ",(0,c.jsx)(a.code,{children:"x"})," variable. This is an example of a closure with lexical scope."]}),(0,c.jsxs)(a.p,{children:[(0,c.jsx)(a.strong,{children:"Block Scope in ES6:"}),"  In ECMAScript 6 (ES6), the ",(0,c.jsx)(a.code,{children:"let"})," and ",(0,c.jsx)(a.code,{children:"const"})," keywords are introduced to declare block-scoped variables. Block scope is not available in ECMAScript 5 (ES5) and earlier versions."]}),(0,c.jsxs)(a.p,{children:[(0,c.jsx)(a.strong,{children:"Hoisting:"}),"  In JavaScript, variable declarations are hoisted to the top of their scope. This means that you can access a variable before it is declared. However, the value of the variable is not hoisted. Only the declaration is hoisted."]}),(0,c.jsxs)(a.p,{children:[(0,c.jsx)(a.strong,{children:"Temporal Dead Zone (TDZ):"}),"  In ECMAScript 6 (ES6), the ",(0,c.jsx)(a.code,{children:"let"})," and ",(0,c.jsx)(a.code,{children:"const"})," variables are hoisted to the top of their scope, but they are not initialized. This period between the creation of the variable and its initialization is called the Temporal Dead Zone (TDZ). If you try to access a ",(0,c.jsx)(a.code,{children:"let"})," or ",(0,c.jsx)(a.code,{children:"const"})," variable before it is initialized, you will get a ReferenceError."]}),(0,c.jsxs)(a.p,{children:[(0,c.jsx)(a.strong,{children:"Global Object:"}),"  In JavaScript, the global object is the object that holds global variables and functions. In a web browser, the global object is the ",(0,c.jsx)(a.code,{children:"window"})," object. In Node.js, the global object is the ",(0,c.jsx)(a.code,{children:"global"})," object."]}),(0,c.jsxs)(a.p,{children:[(0,c.jsx)(a.strong,{children:"Strict Mode:"}),"  In JavaScript, strict mode is a way to opt in to a restricted variant of JavaScript. Strict mode makes it easier to write secure JavaScript code by catching common mistakes and preventing unsafe features from running. Strict mode also changes the behavior of the ",(0,c.jsx)(a.code,{children:"this"})," keyword and disallows the use of undeclared variables."]}),(0,c.jsxs)(a.p,{children:[(0,c.jsx)(a.strong,{children:"Module Scope:"}),"  In ECMAScript 6 (ES6), JavaScript introduces the concept of modules. A module is a file that contains JavaScript code. Each module has its own scope, and the variables and functions defined in a module are not accessible outside of the module unless they are explicitly exported."]})]}),"\n",(0,c.jsx)(a.h2,{id:"scope-chain",children:"Scope Chain"}),"\n",(0,c.jsx)(a.p,{children:"The scope chain is the order in which JavaScript resolves variable names. When a variable is referenced, JavaScript looks up the variable in the scope in which it was defined. If the variable is not found in the current scope, JavaScript looks up the variable in the outer scope. This process continues until the variable is found or the global scope is reached. The scope chain is determined by the lexical scope of the code."}),"\n",(0,c.jsx)(a.p,{children:"Here is an example of the scope chain:"}),"\n",(0,c.jsx)(a.pre,{children:(0,c.jsx)(a.code,{className:"language-javascript",metastring:'title="app.js"',children:'let name = "Ajay Dhangar"; // Global variable\n\nfunction greet() {\n    let message = "Hello, " + name; // Accessing global variable\n    console.log(message);\n}\n\ngreet(); // Output: Hello, Ajay Dhangar\n'})}),"\n",(0,c.jsxs)(a.p,{children:["In the above example, the ",(0,c.jsx)(a.code,{children:"greet"})," function can access the ",(0,c.jsx)(a.code,{children:"name"})," variable, which is defined in the global scope. This is an example of the scope chain."]}),"\n",(0,c.jsx)(a.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,c.jsx)(a.p,{children:"In this tutorial, we learned about scopes in JavaScript. A scope is a region of a program where a variable is defined and can be accessed. JavaScript has three types of scopes: global scope, local scope (function scope), and block scope. We also learned about lexical scope, which is used by JavaScript to resolve variable names."})]})}function p(e={}){const{wrapper:a}={...(0,s.M)(),...e.components};return a?(0,c.jsx)(a,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},4552:(e,a,o)=>{o.d(a,{I:()=>l,M:()=>n});var c=o(11504);const s={},i=c.createContext(s);function n(e){const a=c.useContext(i);return c.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:n(e.components),c.createElement(i.Provider,{value:a},e.children)}}}]);