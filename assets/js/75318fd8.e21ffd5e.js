"use strict";(self.webpackChunkcode_harbor_hub=self.webpackChunkcode_harbor_hub||[]).push([[8109],{74116:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>g,contentTitle:()=>h,default:()=>z,frontMatter:()=>u,metadata:()=>t,toc:()=>x});const t=JSON.parse('{"id":"react-js/advanced-level/component-optimization/lesson-1","title":"Techniques for improving React app performance (memoization, lazy loading)","description":"In this lesson, you will learn about techniques for improving the performance of your React applications. We will cover memoization, lazy loading, and other optimization strategies that can help make your apps faster and more efficient.","source":"@site/courses/react-js/advanced-level/component-optimization/lesson_1.md","sourceDirName":"react-js/advanced-level/component-optimization","slug":"/react-js/advanced-level/component-optimization/lesson-1","permalink":"/courses/react-js/advanced-level/component-optimization/lesson-1","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"courses","permalink":"/courses/tags/courses"},{"inline":true,"label":"react-js","permalink":"/courses/tags/react-js"},{"inline":true,"label":"advanced-level","permalink":"/courses/tags/advanced-level"},{"inline":true,"label":"component-optimization","permalink":"/courses/tags/component-optimization"},{"inline":true,"label":"performance","permalink":"/courses/tags/performance"},{"inline":true,"label":"memoization","permalink":"/courses/tags/memoization"},{"inline":true,"label":"lazy-loading","permalink":"/courses/tags/lazy-loading"},{"inline":true,"label":"optimization","permalink":"/courses/tags/optimization"}],"version":"current","lastUpdatedBy":"Restyled.io","lastUpdatedAt":1713173422000,"sidebarPosition":1,"frontMatter":{"id":"lesson-1","title":"Techniques for improving React app performance (memoization, lazy loading)","sidebar_label":"Lesson - 1","sidebar_position":1,"description":"In this lesson, you will learn about techniques for improving the performance of your React applications. We will cover memoization, lazy loading, and other optimization strategies that can help make your apps faster and more efficient.","tags":["courses","react-js","advanced-level","component-optimization","performance","memoization","lazy-loading","optimization"]},"sidebar":"tutorialSidebar","previous":{"title":"Module 11: Component Optimization","permalink":"/courses/category/module-11-component-optimization"},"next":{"title":"Lesson - 2","permalink":"/courses/react-js/advanced-level/component-optimization/lesson-2"}}');var o=i(74848),a=i(28453),s=i(96540);const r=e=>{let{value:n}=e;const i=(0,s.useMemo)((()=>(e=>2*e)(n)),[n]);return(0,o.jsx)("div",{children:i})},l=()=>{const[e,n]=(0,s.useState)(0);return(0,o.jsxs)("div",{children:[(0,o.jsx)(r,{value:e}),(0,o.jsx)("button",{onClick:()=>n(e+1),children:"Increment"})]})},c=s.lazy((()=>i.e(76645).then(i.bind(i,76645)))),d=()=>(0,o.jsx)(s.Suspense,{fallback:(0,o.jsx)("div",{children:"Loading..."}),children:(0,o.jsx)(c,{})});var p=i(75723);const m=()=>(0,o.jsx)(p.Y1,{height:300,width:"auto",itemSize:50,itemCount:50,children:e=>{let{index:n,style:i}=e;return(0,o.jsxs)("div",{style:i,children:["Row ",n]})}}),u={id:"lesson-1",title:"Techniques for improving React app performance (memoization, lazy loading)",sidebar_label:"Lesson - 1",sidebar_position:1,description:"In this lesson, you will learn about techniques for improving the performance of your React applications. We will cover memoization, lazy loading, and other optimization strategies that can help make your apps faster and more efficient.",tags:["courses","react-js","advanced-level","component-optimization","performance","memoization","lazy-loading","optimization"]},h=void 0,g={},x=[{value:"Memoization",id:"memoization",level:2},{value:"Lazy Loading",id:"lazy-loading",level:2},{value:"Other Optimization Strategies",id:"other-optimization-strategies",level:2},{value:"Conclusion",id:"conclusion",level:2}];function f(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{BrowserWindow:i,TabItem:t,Tabs:s}=n;return i||v("BrowserWindow",!0),t||v("TabItem",!0),s||v("Tabs",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"In React applications, performance is a critical factor that can make or break the user experience. Slow apps can frustrate users and lead to high bounce rates, while fast apps can keep users engaged and coming back for more. In this lesson, we will cover some techniques for improving the performance of your React applications."}),"\n",(0,o.jsx)(n.h2,{id:"memoization",children:"Memoization"}),"\n",(0,o.jsx)(n.p,{children:"Memoization is a technique used to optimize the performance of functions by caching the results of expensive function calls and returning the cached result when the same inputs occur again. This can help reduce the number of times a function is called and improve the overall performance of your application."}),"\n",(0,o.jsx)(n.p,{children:"Here's an example of how memoization can be used in a React component:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:'title="MemoizationExample.js"',children:'import React, { useState, useMemo } from "react";\nconst ExpensiveComponent = ({ value }) => {\n  const expensiveFunction = (value) => {\n    // Expensive computation\n    return value * 2;\n  };\n  const memoizedValue = useMemo(() => expensiveFunction(value), [value]);\n  return <div>{memoizedValue}</div>;\n};\nconst MemoizationExample = () => {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <ExpensiveComponent value={count} />\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n};\nexport default MemoizationExample;\n'})}),"\n",(0,o.jsx)(i,{minHeight:200,children:(0,o.jsx)(l,{})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, the ",(0,o.jsx)(n.code,{children:"ExpensiveComponent"})," component takes a ",(0,o.jsx)(n.code,{children:"value"})," prop and uses the ",(0,o.jsx)(n.code,{children:"useMemo"})," hook to memoize the result of the ",(0,o.jsx)(n.code,{children:"expensiveFunction"})," function. The ",(0,o.jsx)(n.code,{children:"expensiveFunction"})," function is only called when the ",(0,o.jsx)(n.code,{children:"value"})," prop changes, and the memoized result is returned when the component re-renders with the same ",(0,o.jsx)(n.code,{children:"value"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"lazy-loading",children:"Lazy Loading"}),"\n",(0,o.jsx)(n.p,{children:"Lazy loading is a technique used to defer the loading of non-essential resources until they are needed. This can help reduce the initial load time of your application and improve the overall performance by loading resources on-demand."}),"\n",(0,o.jsxs)(n.p,{children:["In React, lazy loading can be achieved using the ",(0,o.jsx)(n.code,{children:"React.lazy"})," function and the ",(0,o.jsx)(n.code,{children:"Suspense"})," component. Here's an example of how lazy loading can be used in a React application:"]}),"\n",(0,o.jsxs)(s,{children:[(0,o.jsx)(t,{value:"LazyLoadingExample",label:"LazyLoadingExample.js",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:'title="LazyLoadingExample.js"',children:'import React, { Suspense } from "react";\nconst LazyComponent = React.lazy(() => import("./LazyComponent"));\nconst LazyLoadingExample = () => {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n     <LazyComponent />\n   </Suspense>\n  );\n};\nexport default LazyLoadingExample;\n'})})}),(0,o.jsx)(t,{value:"LazyComponent",label:"LazyComponent.js",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:'title="LazyComponent.js"',children:"const LazyComponent = () => {\n  return <div>Lazy Component</div>;\n};\nexport default LazyComponent;\n"})})})]}),"\n",(0,o.jsx)(i,{minHeight:200,children:(0,o.jsx)(d,{})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, the ",(0,o.jsx)(n.code,{children:"LazyComponent"})," is loaded lazily using the ",(0,o.jsx)(n.code,{children:"React.lazy"})," function, and the ",(0,o.jsx)(n.code,{children:"Suspense"})," component is used to show a loading indicator while the component is being loaded. This can help improve the performance of your application by deferring the loading of non-essential components until they are needed."]}),"\n",(0,o.jsx)(n.h2,{id:"other-optimization-strategies",children:"Other Optimization Strategies"}),"\n",(0,o.jsx)(n.p,{children:"In addition to memoization and lazy loading, there are other optimization strategies you can use to improve the performance of your React applications:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Virtualization"}),": Using virtualized lists and grids can help improve the performance of large lists by rendering only the visible items."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, you can use libraries like ",(0,o.jsx)(n.code,{children:"react-window"})," or ",(0,o.jsx)(n.code,{children:"react-virtualized"})," to virtualize long lists and grids and improve the rendering performance."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:'title="VirtualizationExample.js"',children:'import React from "react";\nimport { FixedSizeList } from "react-window";\nconst VirtualizationExample = () => {\n  const Row = ({ index, style }) => <div style={style}>Row {index}</div>;\n  return (\n    <FixedSizeList height={300} width="auto" itemSize={50} itemCount={50}>\n      {Row}\n    </FixedSizeList>\n  );\n};\nexport default VirtualizationExample;\n'})}),"\n",(0,o.jsx)(i,{minHeight:200,bodyStyle:{padding:0,paddingLeft:"5px"},children:(0,o.jsx)(m,{})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Optimizing Images"}),": Compressing and optimizing images can help reduce the size of your assets and improve the performance of your application."]}),"\n",(0,o.jsx)(n.p,{children:"For example, you can use tools like ImageOptim or TinyPNG to compress images and reduce their file size."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:'title="OptimizedImageExample.js"',children:'import React from "react";\nimport optimizedImage from "./optimized-image.jpg";\nconst OptimizedImageExample = () => {\n  return <img src={optimizedImage} alt="Optimized Image" />;\n};\nexport default OptimizedImageExample;\n'})}),"\n",(0,o.jsx)(i,{children:(0,o.jsx)("img",{src:"/code-harbor-hub/img/svg/logic.svg",alt:"Optimized Image"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Caching"}),": Caching static assets and API responses can help reduce the load time of your application and improve the overall performance."]}),"\n",(0,o.jsx)(n.p,{children:"For example, you can use service workers to cache static assets and implement client-side caching strategies to cache API responses."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:'title="CachingExample.js"',children:'import React, { useState, useEffect } from "react";\nconst CachingExample = () => {\n  const [data, setData] = useState(null);\n  useEffect(() => {\n    const fetchData = async () => {\n      const response = await fetch("https://api.example.com/data");\n      const data = await response.json();\n      setData(data);\n    };\n    fetchData();\n  }, []);\n  return <div>{data ? data : "Loading..."}</div>;\n};\nexport default CachingExample;\n'})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Code Splitting"}),": Splitting your code into smaller chunks and loading them on-demand can help reduce the initial load time of your application and improve the performance."]}),"\n",(0,o.jsx)(n.p,{children:"For example, you can use tools like Webpack or create-react-app to automatically split your code into smaller chunks and load them on-demand."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:'title="CodeSplittingExample.js"',children:'import React, { useState } from "react";\nconst CodeSplittingExample = () => {\n  const [showComponent, setShowComponent] = useState(false);\n  const handleClick = () => setShowComponent(true);\n  return (\n    <div>\n      <button onClick={handleClick}>Load Component</button>\n      {showComponent && <div>Lazy Component</div>}\n    </div>\n  );\n};\nexport default CodeSplittingExample;\n'})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"By using these optimization strategies and other techniques, you can make your React applications faster and more efficient, providing a better user experience for your users."}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"In this lesson, we covered some techniques for improving the performance of your React applications. Memoization can help optimize the performance of expensive functions by caching their results, while lazy loading can defer the loading of non-essential resources until they are needed. By using these techniques and other optimization strategies, you can make your React applications faster and more efficient, providing a better user experience for your users."})]})}function z(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(f,{...e})}):f(e)}function v(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);